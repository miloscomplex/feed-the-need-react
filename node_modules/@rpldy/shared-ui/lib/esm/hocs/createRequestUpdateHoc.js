function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useLayoutEffect, useState } from "react";
import useUploadyContext from "../hooks/useUploadyContext";

const createRequestUpdateHoc = _ref => {
  let {
    eventType,
    getIsValidEventData,
    getRequestData
  } = _ref;
  return Component => props => {
    const context = useUploadyContext();
    const [updater, setUpdater] = useState({
      updateRequest: null,
      requestData: null
    });
    const {
      id
    } = props; //need layout effect to register to event in time (block)

    useLayoutEffect(() => {
      const handleEvent = function () {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        return getIsValidEventData(id, ...params) === true ? //returning a promise to event dispatcher so it will await until its resolved by user-land code
        new Promise(resolve => {
          setUpdater({
            updateRequest: data => {
              //unregister handler so this instance doesnt continue listening unnecessarily
              context.off(eventType, handleEvent);
              resolve(data);
            },
            requestData: getRequestData(...params)
          });
        }) : //returning false for invalid data will cancel the request so must return undefined!
        undefined;
      };

      if (id) {
        context.on(eventType, handleEvent);
      }

      return () => {
        if (id) {
          context.off(eventType, handleEvent);
        }
      };
    }, [context, id]);
    return /*#__PURE__*/React.createElement(Component, _extends({}, props, updater));
  };
};

export { createRequestUpdateHoc };