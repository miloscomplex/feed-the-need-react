"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.triggerUploaderBatchEvent = exports.removePendingBatches = exports.preparePendingForUpload = exports.loadNewBatchForItem = exports.isNewBatchStarting = exports.incrementBatchFinishedCounter = exports.getIsItemBatchReady = exports.getIsBatchFinalized = exports.getBatchFromState = exports.getBatchFromItemId = exports.getBatchDataFromItemId = exports.failBatchForItem = exports.detachRecycledFromPreviousBatch = exports.cleanUpFinishedBatches = exports.cancelBatchForItem = void 0;

var _shared = require("@rpldy/shared");

var _simpleState = require("@rpldy/simple-state");

var _consts = require("../consts");

var _preSendPrepare = require("./preSendPrepare");

var _itemHelpers = require("./itemHelpers");

const prepareBatchStartItems = (0, _preSendPrepare.getItemsPrepareUpdater)(_consts.UPLOADER_EVENTS.BATCH_START, batch => batch.items, null, function () {
  let {
    batch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (batch) {
    throw new Error(`BATCH_START event handlers cannot update batch data. Only items & options`);
  }
});
const BATCH_READY_STATES = [_shared.BATCH_STATES.ADDED, _shared.BATCH_STATES.PROCESSING, _shared.BATCH_STATES.UPLOADING];
const BATCH_FINISHED_STATES = [_shared.BATCH_STATES.ABORTED, _shared.BATCH_STATES.CANCELLED, _shared.BATCH_STATES.FINISHED, _shared.BATCH_STATES.ERROR];

const getBatchFromState = (state, id) => state.batches[id].batch;

exports.getBatchFromState = getBatchFromState;

const getBatch = (queue, id) => {
  return getBatchFromState(queue.getState(), id);
};

const getBatchDataFromItemId = (queue, itemId) => {
  const state = queue.getState();
  const item = state.items[itemId];
  return state.batches[item.batchId];
};

exports.getBatchDataFromItemId = getBatchDataFromItemId;

const getBatchFromItemId = (queue, itemId) => {
  return getBatchDataFromItemId(queue, itemId).batch;
};

exports.getBatchFromItemId = getBatchFromItemId;

const removeBatchItems = (queue, batchId) => {
  const batch = getBatch(queue, batchId);
  batch.items.forEach(_ref => {
    let {
      id
    } = _ref;
    return (0, _itemHelpers.finalizeItem)(queue, id, true);
  });
};

const removeBatch = (queue, batchId) => {
  queue.updateState(state => {
    delete state.batches[batchId];
  });
};

const finalizeBatch = (queue, batchId, eventType) => {
  triggerUploaderBatchEvent(queue, batchId, eventType);
  triggerUploaderBatchEvent(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_FINALIZE);
};

const cancelBatchForItem = (queue, itemId) => {
  const batch = getBatchFromItemId(queue, itemId),
        batchId = batch.id;

  _shared.logger.debugLog("uploady.uploader.batchHelpers: cancelling batch: ", {
    batch
  });

  queue.updateState(state => {
    const batch = getBatchFromState(state, batchId);
    batch.state = _shared.BATCH_STATES.CANCELLED;
  });
  finalizeBatch(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_CANCEL);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};

exports.cancelBatchForItem = cancelBatchForItem;

const failBatchForItem = (queue, itemId, err) => {
  const batch = getBatchFromItemId(queue, itemId),
        batchId = batch.id;

  _shared.logger.debugLog("uploady.uploader.batchHelpers: failing batch: ", {
    batch
  });

  queue.updateState(state => {
    const batch = getBatchFromState(state, batchId);
    batch.state = _shared.BATCH_STATES.ERROR;
    batch.additionalInfo = err.message;
  });
  finalizeBatch(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_ERROR);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};

exports.failBatchForItem = failBatchForItem;

const isNewBatchStarting = (queue, itemId) => {
  const batch = getBatchFromItemId(queue, itemId);
  return queue.getState().currentBatch !== batch.id;
};

exports.isNewBatchStarting = isNewBatchStarting;

const loadNewBatchForItem = (queue, itemId) => {
  const batch = getBatchFromItemId(queue, itemId);
  return prepareBatchStartItems(queue, batch).then(_ref2 => {
    let {
      cancelled
    } = _ref2;

    if (!cancelled) {
      queue.updateState(state => {
        state.currentBatch = batch.id;
      });
    }

    return !cancelled;
  });
};

exports.loadNewBatchForItem = loadNewBatchForItem;

const cleanUpFinishedBatches = queue => {
  //TODO: schedule clean up on requestIdle
  const state = queue.getState();
  Object.keys(state.batches).forEach(batchId => {
    const {
      batch,
      finishedCounter
    } = state.batches[batchId];
    const {
      orgItemCount
    } = batch; //shouldnt be the case, but if wasnt cleaned before, it will now

    const alreadyFinalized = getIsBatchFinalized(batch);

    if (orgItemCount === finishedCounter) {
      //batch may not be updated with completed/loaded with 100% values
      if (!alreadyFinalized && batch.completed !== 100) {
        queue.updateState(state => {
          const batch = getBatchFromState(state, batchId);
          batch.completed = 100;
          batch.loaded = batch.items.reduce((res, _ref3) => {
            let {
              loaded
            } = _ref3;
            return res + loaded;
          }, 0);
        }); //ensure we trigger progress event with completed = 100 for all items

        triggerUploaderBatchEvent(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_PROGRESS);
      }

      queue.updateState(state => {
        const batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue

        batch.state = alreadyFinalized ? batch.state : _shared.BATCH_STATES.FINISHED;

        if (state.currentBatch === batchId) {
          state.currentBatch = null;
        }
      });

      _shared.logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);

      if (!alreadyFinalized) {
        finalizeBatch(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_FINISH);
      }

      removeBatchItems(queue, batchId);
      removeBatch(queue, batchId);
    }
  });
};

exports.cleanUpFinishedBatches = cleanUpFinishedBatches;

const triggerUploaderBatchEvent = (queue, batchId, event) => {
  const state = queue.getState(),
        batch = getBatchFromState(state, batchId),
        //get the most uptodate batch data
  stateItems = state.items;
  const eventBatch = { ...(0, _simpleState.unwrap)(batch),
    items: batch.items.map(_ref4 => {
      let {
        id
      } = _ref4;
      return (0, _simpleState.unwrap)(stateItems[id]);
    })
  };
  queue.trigger(event, eventBatch);
};

exports.triggerUploaderBatchEvent = triggerUploaderBatchEvent;

const getIsItemBatchReady = (queue, itemId) => {
  const batch = getBatchFromItemId(queue, itemId);
  return BATCH_READY_STATES.includes(batch.state);
};

exports.getIsItemBatchReady = getIsItemBatchReady;

const detachRecycledFromPreviousBatch = (queue, item) => {
  const {
    previousBatch
  } = item;

  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {
    const {
      id: batchId
    } = getBatchFromItemId(queue, item.id);

    if (batchId === previousBatch) {
      queue.updateState(state => {
        const batch = getBatchFromState(state, batchId);
        const index = batch.items.findIndex(_ref5 => {
          let {
            id
          } = _ref5;
          return id === item.id;
        });

        if (~index) {
          batch.items.splice(index, 1);
        }
      });
    }
  }
};

exports.detachRecycledFromPreviousBatch = detachRecycledFromPreviousBatch;

const preparePendingForUpload = (queue, uploadOptions) => {
  queue.updateState(state => {
    //remove pending state from pending batches
    Object.keys(state.batches).forEach(batchId => {
      const batchData = state.batches[batchId];
      const {
        batch,
        batchOptions
      } = batchData;

      if (batch.state === _shared.BATCH_STATES.PENDING) {
        batch.items.forEach(item => {
          item.state = _shared.FILE_STATES.ADDED;
        });
        batch.state = _shared.BATCH_STATES.ADDED;
        batchData.batchOptions = (0, _shared.merge)({}, batchOptions, uploadOptions);
      }
    });
  });
};

exports.preparePendingForUpload = preparePendingForUpload;

const removePendingBatches = queue => {
  const batches = queue.getState().batches;
  Object.keys(batches).filter(batchId => batches[batchId].batch.state === _shared.BATCH_STATES.PENDING).forEach(batchId => {
    removeBatchItems(queue, batchId);
    removeBatch(queue, batchId);
  });
};

exports.removePendingBatches = removePendingBatches;

const incrementBatchFinishedCounter = (queue, batchId) => {
  queue.updateState(state => {
    state.batches[batchId].finishedCounter += 1;
  });
};

exports.incrementBatchFinishedCounter = incrementBatchFinishedCounter;

const getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);

exports.getIsBatchFinalized = getIsBatchFinalized;